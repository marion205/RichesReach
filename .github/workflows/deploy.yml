name: Build & Deploy Backend

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 498606688292
  ECR_REPO: riches-reach-ai
  CLUSTER: riches-reach-cluster
  SERVICE: riches-reach-streaming-service
  TASK_FAMILY: riches-reach-streaming-pipeline-optimized
  CONTAINER_NAME: streaming-pipeline

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Option B: Static keys via repo secrets (easier to set up)
      - name: Configure AWS (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute tags
        id: meta
        run: |
          GIT_SHA="${GITHUB_SHA}"
          HUMAN_TAG="prod-$(date +%Y%m%d%H%M%S)"
          IMAGE_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${GIT_SHA}"
          echo "GIT_SHA=$GIT_SHA" >> $GITHUB_OUTPUT
          echo "HUMAN_TAG=$HUMAN_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Build & push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: backend/backend/Dockerfile.production
          build-args: |
            GIT_SHA=${{ steps.meta.outputs.GIT_SHA }}
          push: true
          no-cache: true
          tags: |
            ${{ steps.meta.outputs.IMAGE_URI }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${{ steps.meta.outputs.HUMAN_TAG }}

      - name: Verify code inside image
        run: |
          ECR_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}"
          IMG="$ECR_URI:${{ steps.meta.outputs.GIT_SHA }}"
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${ECR_URI%/*}"
          docker pull "$IMG"
          id=$(docker create "$IMG")
          docker cp "$id:/app/richesreach/wsgi.py" wsgi.from.image.py || true
          docker cp "$id:/app/richesreach/settings_production.py" settings_prod.from.image.py || true
          docker rm "$id"
          echo "---- wsgi.py head ----"; head -n 40 wsgi.from.image.py || true
          echo "---- settings_production.py head ----"; head -n 40 settings_prod.from.image.py || true

          # Assert the sentinel is present (the setdefault line you added)
          grep -q "os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"richesreach.settings_production\")" wsgi.from.image.py

      - name: Patch & register task definition
        id: td
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ env.TASK_FAMILY }}" \
            --query 'taskDefinition' > td.json

          IMG="${{ steps.meta.outputs.IMAGE_URI }}"
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg IMG "$IMG" '
            .containerDefinitions |= (map(
              if .name==$NAME then 
                .image=$IMG | 
                .environment |= (
                  map(select(.name != "DJANGO_SETTINGS_MODULE")) + 
                  [{name: "DJANGO_SETTINGS_MODULE", value: "richesreach.settings_production"}]
                )
              else . end
            )) |
            {family, taskRoleArn, executionRoleArn, networkMode, containerDefinitions,
             volumes, placementConstraints, requiresCompatibilities, cpu, memory}
          ' td.json > new-td.json

          REV_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-td.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "REV_ARN=$REV_ARN" >> $GITHUB_OUTPUT

      - name: Update service
        run: |
          aws ecs update-service \
            --cluster "${{ env.CLUSTER }}" \
            --service "${{ env.SERVICE }}" \
            --task-definition "${{ steps.td.outputs.REV_ARN }}" \
            --force-new-deployment
          aws ecs wait services-stable \
            --cluster "${{ env.CLUSTER }}" \
            --services "${{ env.SERVICE }}"

      - name: Smoke tests
        run: |
          API="http://riches-reach-alb-1199497064.${{ env.AWS_REGION }}.elb.amazonaws.com"
          echo "Waiting for deployment to be ready..."
          for i in {1..10}; do
            echo "Attempt $i: /health"
            if curl -fsS "$API/health" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed"
              break
            else
              echo "‚è≥ Health check failed, waiting 6s..."
              sleep 6
            fi
          done
          
          echo ""
          echo "üß™ Running smoke tests..."
          echo "GET /health   ->"; curl -i "$API/health"  | head -n 1 || echo "‚ùå FAIL"
          echo "GET /health/  ->"; curl -i "$API/health/" | head -n 1 || echo "‚ùå FAIL"
          echo "GET /echo     ->"; curl -i "$API/echo"    | head -n 1 || echo "‚ùå FAIL"
          echo "GET /netcheck ->"; curl -i "$API/netcheck" | head -n 1 || echo "‚ùå FAIL"
          
          echo ""
          echo "üéâ Deployment complete! The application should now be stable with:"
          echo "  - Lazy Yodlee service loading (no import-time crashes)"
          echo "  - Lazy GraphQL schema loading (health checks independent)"
          echo "  - Both /health and /health/ endpoints working"
          echo "  - Graceful handling of missing Yodlee configuration"