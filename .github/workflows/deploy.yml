name: Build & Deploy Backend

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 498606688292
  ECR_REPO: riches-reach-ai
  CLUSTER: riches-reach-cluster
  SERVICE: riches-reach-streaming-service
  TASK_FAMILY: riches-reach-streaming-pipeline-optimized
  CONTAINER_NAME: streaming-pipeline

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify build context
        run: |
          echo "üîç Checking build context size..."
          du -sh . || echo "du command not available"
          echo "üìÅ Backend directory size:"
          du -sh backend/backend/ || echo "Backend directory not found"
          echo "üìã Files that will be included in build:"
          find . -name "*.py" -path "./backend/backend/*" | head -10 || echo "No Python files found"

      # Option B: Static keys via repo secrets (easier to set up)
      - name: Configure AWS (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute tags
        id: meta
        run: |
          GIT_SHA="${GITHUB_SHA}"
          HUMAN_TAG="prod-$(date +%Y%m%d%H%M%S)"
          IMAGE_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}:${GIT_SHA}"
          echo "GIT_SHA=$GIT_SHA" >> $GITHUB_OUTPUT
          echo "HUMAN_TAG=$HUMAN_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Build & push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: backend/backend/Dockerfile.production
          push: true
          platforms: linux/amd64
          build-args: |
            GIT_SHA=${{ steps.meta.outputs.GIT_SHA }}
            BUILD_MARKER=${{ github.run_id }}-${{ github.run_attempt }}
          tags: ${{ steps.meta.outputs.IMAGE_URI }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: true
          provenance: false

      - name: Show image digest in ECR
        run: |
          aws ecr describe-images \
            --repository-name "${{ env.ECR_REPO }}" \
            --image-ids imageTag="${{ steps.meta.outputs.GIT_SHA }}" \
            --query 'imageDetails[0].[imagePushedAt,imageDigest]' \
            --output table

      - name: Pull and verify code inside image
        run: |
          ECR_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}"
          IMG="$ECR_URI:${{ steps.meta.outputs.GIT_SHA }}"
          aws ecr get-login-password --region "${{ env.AWS_REGION }}" \
            | docker login --username AWS --password-stdin "${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          docker pull "$IMG"

          echo "== __build.txt =="
          docker run --rm "$IMG" cat /app/__build.txt || true

          echo "== celery header =="
          docker run --rm "$IMG" /bin/sh -lc 'sed -n "1,40p" /app/richesreach/celery.py || true'

          echo "== __init__.py header =="
          docker run --rm "$IMG" /bin/sh -lc 'sed -n "1,40p" /app/richesreach/__init__.py || true'

          echo "== import test (should not crash) =="
          docker run --rm -e DJANGO_SETTINGS_MODULE=richesreach.settings_production "$IMG" python - <<'PY'
import importlib, os
print("DJANGO_SETTINGS_MODULE=", os.environ.get("DJANGO_SETTINGS_MODULE"))
importlib.import_module("richesreach.celery")
print("celery import OK")
importlib.import_module("richesreach.settings_production")
print("settings_production import OK")
PY

      - name: Patch & register task definition
        id: td
        run: |
          aws ecs describe-task-definition \
            --task-definition "${{ env.TASK_FAMILY }}" \
            --query 'taskDefinition' > td.json

          IMG="${{ steps.meta.outputs.IMAGE_URI }}"
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg IMG "$IMG" '
            .containerDefinitions |= (map(
              if .name==$NAME then 
                .image=$IMG | 
                .environment |= (
                  map(select(.name != "DJANGO_SETTINGS_MODULE")) + 
                  [{name: "DJANGO_SETTINGS_MODULE", value: "richesreach.settings_production"}]
                )
              else . end
            )) |
            {family, taskRoleArn, executionRoleArn, networkMode, containerDefinitions,
             volumes, placementConstraints, requiresCompatibilities, cpu, memory}
          ' td.json > new-td.json

          REV_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-td.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "REV_ARN=$REV_ARN" >> $GITHUB_OUTPUT

      - name: Update service
        run: |
          aws ecs update-service \
            --cluster "${{ env.CLUSTER }}" \
            --service "${{ env.SERVICE }}" \
            --task-definition "${{ steps.td.outputs.REV_ARN }}" \
            --force-new-deployment
          aws ecs wait services-stable \
            --cluster "${{ env.CLUSTER }}" \
            --services "${{ env.SERVICE }}"

      - name: Smoke tests
        run: |
          API="http://riches-reach-alb-1199497064.${{ env.AWS_REGION }}.elb.amazonaws.com"
          echo "Waiting for deployment to be ready..."
          for i in {1..10}; do
            echo "Attempt $i: /health"
            if curl -fsS "$API/health" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed"
              break
            else
              echo "‚è≥ Health check failed, waiting 6s..."
              sleep 6
            fi
          done
          
          echo ""
          echo "üß™ Running smoke tests..."
          echo "GET /health   ->"; curl -i "$API/health"  | head -n 1 || echo "‚ùå FAIL"
          echo "GET /health/  ->"; curl -i "$API/health/" | head -n 1 || echo "‚ùå FAIL"
          echo "GET /echo     ->"; curl -i "$API/echo"    | head -n 1 || echo "‚ùå FAIL"
          echo "GET /netcheck ->"; curl -i "$API/netcheck" | head -n 1 || echo "‚ùå FAIL"
          
          echo ""
          echo "üéâ Deployment complete! The application should now be stable with:"
          echo "  - Lazy Yodlee service loading (no import-time crashes)"
          echo "  - Lazy GraphQL schema loading (health checks independent)"
          echo "  - Both /health and /health/ endpoints working"
          echo "  - Graceful handling of missing Yodlee configuration"