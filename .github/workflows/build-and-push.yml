name: Build & Push to ECR

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 498606688292.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: riches-reach-streaming

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Sanity checks so this never breaks silently
      - name: Verify build inputs
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          ls -al
          test -f Dockerfile || (echo "Dockerfile missing at repo root"; exit 1)
          test -f backend/backend/backend/requirements.txt || (echo "backend/backend/backend/requirements.txt missing"; exit 1)
          test -f backend/backend/backend/richesreach/settings_production.py || (echo "settings_production.py missing"; exit 1)
          echo "âœ… All build inputs verified"

      # Generate consistent tags (sha + latest on main)
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=sha,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          no-cache: true

      # Use the digest output directly (don't "describe-images" by tag)
      - name: Show pushed image info
        run: |
          echo "Tags pushed:"
          echo "${{ steps.meta.outputs.tags }}"
          echo "Digest:"
          echo "${{ steps.build.outputs.digest }}"

    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image_repo: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fail if digest missing
        run: |
          if [ -z "${{ needs.build.outputs.digest }}" ]; then
            echo "No digest from build step"; exit 1
          fi
          echo "Digest OK: ${{ needs.build.outputs.digest }}"

      - name: Fetch current ECS task definition
        run: |
          aws ecs describe-services \
            --cluster riches-reach-cluster \
            --services riches-reach-streaming-service \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text > td_arn.txt
          aws ecs describe-task-definition \
            --task-definition "$(cat td_arn.txt)" \
            --region ${{ env.AWS_REGION }} > td.json

      - name: Swap container image to immutable digest
        run: |
          IMG="${{ needs.build.outputs.image_repo }}@${{ needs.build.outputs.digest }}"
          jq --arg IMG "$IMG" '
            .taskDefinition.containerDefinitions[0].image = $IMG
            | .taskDefinition.containerDefinitions
          ' td.json > container-defs.json

          CPU=$(jq -r '.taskDefinition.cpu' td.json)
          MEM=$(jq -r '.taskDefinition.memory' td.json)
          NET=$(jq -r '.taskDefinition.networkMode' td.json)
          EXEC_ROLE=$(jq -r '.taskDefinition.executionRoleArn' td.json)
          TASK_ROLE=$(jq -r '.taskDefinition.taskRoleArn' td.json)
          REQUIRES=$(jq -c '.taskDefinition.requiresCompatibilities' td.json)
          VOLUMES=$(jq -c '.taskDefinition.volumes' td.json)
          FAMILY=$(jq -r '.taskDefinition.family' td.json)

          NEW_TD=$(
            aws ecs register-task-definition \
              --family "$FAMILY" \
              --network-mode "$NET" \
              --execution-role-arn "$EXEC_ROLE" \
              --task-role-arn "$TASK_ROLE" \
              --cpu "$CPU" \
              --memory "$MEM" \
              --requires-compatibilities "$REQUIRES" \
              --container-definitions file://container-defs.json \
              --volumes "$VOLUMES" \
              --region ${{ env.AWS_REGION }} \
              --query 'taskDefinition.taskDefinitionArn' --output text
          )
          echo "NEW_TD=$NEW_TD" >> $GITHUB_ENV
          echo "Registered TD: $NEW_TD"

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster riches-reach-cluster \
            --service riches-reach-streaming-service \
            --task-definition "$NEW_TD" \
            --region ${{ env.AWS_REGION }}
          aws ecs wait services-stable \
            --cluster riches-reach-cluster \
            --services riches-reach-streaming-service \
            --region ${{ env.AWS_REGION }}
          echo "Service updated to $NEW_TD"
