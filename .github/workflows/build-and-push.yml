name: Build & Push to ECR

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - "Dockerfile"
      - "backend/**"
      - ".github/workflows/build-and-push.yml"
  pull_request:
    branches: [ main ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 498606688292.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: riches-reach-streaming
  PYTHON_VERSION: "3.12"
  APP_DIR: "backend/backend/backend/backend"  # Single source of truth

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"
          cache-dependency-path: ${{ env.APP_DIR }}/requirements.txt

      - name: Verify project layout
        run: bash scripts/verify-layout.sh

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r "${APP_DIR}/requirements.txt"

      - name: Django checks
        working-directory: ${{ env.APP_DIR }}
        env:
          DJANGO_SETTINGS_MODULE: richesreach.settings
        run: |
          python manage.py check
          # Run tests if available
          if [ -f "manage.py" ]; then
            python manage.py test --noinput || echo "⚠️ Tests failed but continuing..."
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Compute consistent tags (single source of truth)
      - name: Compute tags
        id: tags
        run: |
          RAW_SHA="${GITHUB_SHA}"
          SHA_TAG="${RAW_SHA}"              # raw sha (no prefix)
          SHA_TAG_PREFIXED="sha-${RAW_SHA}" # prefixed variant
          BRANCH_TAG="${GITHUB_REF_NAME//\//-}"
          echo "raw=${SHA_TAG}" >> $GITHUB_OUTPUT
          echo "pref=${SHA_TAG_PREFIXED}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH_TAG}" >> $GITHUB_OUTPUT
          echo "latest=latest" >> $GITHUB_OUTPUT

      - name: Show workspace & Dockerfile
        run: |
          pwd
          ls -la
          test -f ./Dockerfile || (echo "Dockerfile not found in $(pwd)"; exit 1)
          echo "Build context will be: ."

      - name: Verify expected files exist
        run: |
          APP_DIR="${{ env.APP_DIR }}"
          echo "Checking files in: $APP_DIR"
          test -f "$APP_DIR/requirements.txt" || { echo "❌ Missing $APP_DIR/requirements.txt"; exit 1; }
          test -f "$APP_DIR/manage.py" || { echo "❌ Missing $APP_DIR/manage.py"; exit 1; }
          test -d "$APP_DIR/richesreach" || { echo "❌ Missing $APP_DIR/richesreach/ directory"; exit 1; }
          echo "✅ All required files found"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .                # Explicit context - no variables
          file: ./Dockerfile
          push: true                # Avoids "No output specified" warning
          platforms: linux/amd64
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.raw }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.pref }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.branch }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.latest }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:buildcache,mode=max

      # Show pushed image info
      - name: Show pushed image info
        run: |
          echo "Tags pushed:"
          echo "- ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.raw }}"
          echo "- ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.pref }}"
          echo "- ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.branch }}"
          echo "- ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.latest }}"
          echo "Digest:"
          echo "${{ steps.build.outputs.digest }}"

      # ✅ Verify the exact tag(s) we just pushed
      - name: Verify pushed image exists
        run: |
          echo "Verifying pushed images exist in ECR..."
          aws ecr describe-images --repository-name "${{ env.ECR_REPOSITORY }}" --image-ids imageTag="${{ steps.tags.outputs.raw }}"
          aws ecr describe-images --repository-name "${{ env.ECR_REPOSITORY }}" --image-ids imageTag="${{ steps.tags.outputs.pref }}"
          echo "✅ Both raw and prefixed SHA tags verified in ECR"

      # Verify app paths inside image
      - name: Verify app paths inside image
        run: |
          ID=$(docker create ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tags.outputs.raw }})
          docker cp "$ID":/app/manage.py /tmp/manage.py || (echo "❌ /app/manage.py missing in image"; exit 3)
          docker cp "$ID":/app/richesreach/settings_production.py /tmp/ || (echo "❌ settings_production.py missing in image"; exit 3)
          docker rm "$ID"
          echo "✅ App files present in the image"

    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image_repo: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fail if digest missing
        run: |
          if [ -z "${{ needs.test-and-build.outputs.digest }}" ]; then
            echo "No digest from build step"; exit 1
          fi
          echo "Digest OK: ${{ needs.test-and-build.outputs.digest }}"

      - name: Fetch current ECS task definition
        run: |
          aws ecs describe-services \
            --cluster riches-reach-cluster \
            --services riches-reach-streaming-service \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text > td_arn.txt
          aws ecs describe-task-definition \
            --task-definition "$(cat td_arn.txt)" \
            --region ${{ env.AWS_REGION }} > td.json

      - name: Swap container image to immutable digest
        run: |
          # Use the raw SHA tag that we know exists
          IMG="${{ needs.test-and-build.outputs.image_repo }}:${{ github.sha }}"
          echo "Using image: $IMG"
          jq --arg IMG "$IMG" '
            .taskDefinition.containerDefinitions[0].image = $IMG
            | .taskDefinition.containerDefinitions
          ' td.json > container-defs.json

          CPU=$(jq -r '.taskDefinition.cpu' td.json)
          MEM=$(jq -r '.taskDefinition.memory' td.json)
          NET=$(jq -r '.taskDefinition.networkMode' td.json)
          EXEC_ROLE=$(jq -r '.taskDefinition.executionRoleArn' td.json)
          TASK_ROLE=$(jq -r '.taskDefinition.taskRoleArn' td.json)
          REQUIRES=$(jq -c '.taskDefinition.requiresCompatibilities' td.json)
          VOLUMES=$(jq -c '.taskDefinition.volumes' td.json)
          FAMILY=$(jq -r '.taskDefinition.family' td.json)

          NEW_TD=$(
            aws ecs register-task-definition \
              --family "$FAMILY" \
              --network-mode "$NET" \
              --execution-role-arn "$EXEC_ROLE" \
              --task-role-arn "$TASK_ROLE" \
              --cpu "$CPU" \
              --memory "$MEM" \
              --requires-compatibilities "$REQUIRES" \
              --container-definitions file://container-defs.json \
              --volumes "$VOLUMES" \
              --region ${{ env.AWS_REGION }} \
              --query 'taskDefinition.taskDefinitionArn' --output text
          )
          echo "NEW_TD=$NEW_TD" >> $GITHUB_ENV
          echo "Registered TD: $NEW_TD"

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster riches-reach-cluster \
            --service riches-reach-streaming-service \
            --task-definition "$NEW_TD" \
            --region ${{ env.AWS_REGION }}
          aws ecs wait services-stable \
            --cluster riches-reach-cluster \
            --services riches-reach-streaming-service \
            --region ${{ env.AWS_REGION }}
          echo "Service updated to $NEW_TD"