# RichesReach Education GraphQL Schema
# Beats Fidelity with adaptive learning, voice integration, and gamification

extend type Query {
  # User Progress & Analytics
  tutorProgress: TutorProgress!
  tutorAnalytics: TutorAnalytics!
  tutorLeague(circle: String!, period: String!): [LeagueEntry!]!
  
  # Content & Lessons
  availableLessons(topic: String, regime: String): [LessonPreview!]!
  lessonContent(lessonId: ID!): Lesson!
  userBadges: [Badge!]!
  
  # Quests & Challenges
  dailyQuest: Quest!
  availableQuests: [Quest!]!
  questProgress(questId: ID!): QuestProgress!
  
  # Live Simulations
  activeSimSessions: [SimSession!]!
  simSession(sessionId: ID!): SimSession!
  
  # Community & Leagues
  circlesLeagues: [CircleLeague!]!
  userRanking(circle: String!): UserRanking!
}

extend type Mutation {
  # Learning Actions
  startLesson(topic: String!, regime: String): Lesson!
  submitQuiz(lessonId: ID!, answers: [Int!]!): QuizResult!
  requestExplanation(questionId: ID!): Explanation!
  
  # Gamification
  claimStreakFreeze: TutorProgress!
  claimBadge(badgeId: ID!): BadgeClaimResult!
  joinLeague(circle: String!): LeagueJoinResult!
  
  # Live Simulations
  startLiveSim(symbol: String!, mode: String!): SimSession!
  executeSimTrade(sessionId: ID!, tradeData: SimTradeInput!): SimTradeResult!
  endSimSession(sessionId: ID!): SimSessionResult!
  
  # Quests & Challenges
  startQuest(questId: ID!): QuestStartResult!
  completeQuestObjective(questId: ID!, objectiveId: ID!): QuestProgress!
  abandonQuest(questId: ID!): QuestAbandonResult!
  
  # Voice Integration
  processVoiceCommand(command: String!): VoiceCommandResult!
  setVoicePreference(voiceId: String!): VoicePreferenceResult!
  
  # Community
  shareProgress(circle: String!, achievement: String!): ShareResult!
  challengeFriend(friendId: ID!, challengeType: String!): ChallengeResult!
}

# Core Types

type TutorProgress {
  userId: ID!
  xp: Int!
  level: Int!
  streakDays: Int!
  badges: [String!]!
  lastLogin: DateTime
  abilityEstimate: Float!  # IRT theta
  nextReviewAt: DateTime
  skillMastery: [SkillMastery!]!
  reviewQueue: [String!]!
  hearts: Int!
  maxHearts: Int!
  heartsRegenAt: DateTime
}

type SkillMastery {
  skill: String!
  masteryLevel: Float!
  masteryPercentage: Int!
  status: String!  # "Master", "Learning", "Beginner"
  lastPracticed: DateTime
  timesPracticed: Int!
}

type TutorAnalytics {
  userId: ID!
  totalLessonsCompleted: Int!
  averageScore: Float!
  totalXpEarned: Int!
  longestStreak: Int!
  currentStreak: Int!
  badgesEarned: Int!
  skillsMastered: Int!
  timeSpentLearning: Int!  # minutes
  favoriteTopics: [String!]!
  learningVelocity: Float!  # XP per day
  retentionRate: Float!  # % of knowledge retained
  improvementAreas: [String!]!
  strengths: [String!]!
}

type LeagueEntry {
  userId: ID!
  username: String!
  xpWeek: Int!
  rank: Int!
  circle: String!
  avatarUrl: String
  streakDays: Int!
  badgesCount: Int!
  level: Int!
  lastActive: DateTime
  isOnline: Boolean!
}

type UserRanking {
  userId: ID!
  globalRank: Int!
  circleRank: Int!
  xpThisWeek: Int!
  xpThisMonth: Int!
  improvementThisWeek: Int!
  percentile: Float!
  tier: String!  # "Bronze", "Silver", "Gold", "Platinum", "Diamond"
}

# Lesson Types

type Lesson {
  id: ID!
  title: String!
  text: String!
  voiceNarration: String!
  quiz: [Question!]!
  xpEarned: Int!
  streak: Int!
  nextUnlock: String!
  difficulty: String!
  sources: [String!]!
  regimeContext: String!
  estimatedTimeMinutes: Int!
  skillsTargeted: [String!]!
  bloomLevel: String!
  prerequisites: [String!]!
  completionRate: Float!
  averageRating: Float!
}

type LessonPreview {
  id: ID!
  title: String!
  difficulty: String!
  estimatedTimeMinutes: Int!
  skillsTargeted: [String!]!
  xpReward: Int!
  completionRate: Float!
  isCompleted: Boolean!
  isLocked: Boolean!
  prerequisites: [String!]!
}

type Question {
  id: ID!
  question: String!
  options: [String!]!
  correct: Int!
  explanation: String!
  voiceHint: String!
  difficulty: Float!
  skills: [String!]!
  timeLimit: Int  # seconds
}

type QuizResult {
  score: Float!
  xpBonus: Int!
  totalXp: Int!
  feedback: String!
  badgesEarned: [String!]!
  nextRecommendation: String!
  streakStatus: String!
  levelProgress: LevelProgress!
  questionsReview: [QuestionReview!]!
  timeSpent: Int!  # seconds
  accuracy: Float!
}

type QuestionReview {
  questionId: ID!
  userAnswer: Int!
  correctAnswer: Int!
  isCorrect: Boolean!
  explanation: String!
  timeSpent: Int!
}

type LevelProgress {
  currentLevel: Int!
  currentXp: Int!
  nextLevelXp: Int!
  progressPercentage: Int!
  xpToNextLevel: Int!
}

type Explanation {
  questionId: ID!
  explanation: String!
  voiceNarration: String!
  examples: [String!]!
  relatedConcepts: [String!]!
  practiceSuggestions: [String!]!
  sources: [String!]!
}

# Quest Types

type Quest {
  id: ID!
  title: String!
  description: String!
  questType: String!
  difficulty: Int!
  xpReward: Int!
  timeLimitMinutes: Int!
  requiredSkills: [String!]!
  regimeContext: String!
  voiceNarration: String!
  completionCriteria: QuestCriteria!
  isActive: Boolean!
  createdAt: DateTime!
  expiresAt: DateTime
  participants: Int!
  completionRate: Float!
}

type QuestProgress {
  questId: ID!
  userId: ID!
  status: String!  # "Not Started", "In Progress", "Completed", "Expired"
  progress: Float!  # 0.0 to 1.0
  objectivesCompleted: Int!
  totalObjectives: Int!
  xpEarned: Int!
  timeSpent: Int!  # minutes
  startedAt: DateTime
  completedAt: DateTime
  objectives: [QuestObjective!]!
}

type QuestObjective {
  id: ID!
  title: String!
  description: String!
  isCompleted: Boolean!
  progress: Float!
  xpReward: Int!
  completedAt: DateTime
}

type QuestCriteria {
  scenariosCompleted: Int
  successRate: Float
  quizzesPassed: Int
  scoreThreshold: Int
  duelsWon: Int
  accuracy: Float
  strategiesLearned: Int
  communityEngagement: Int
  simulationsCompleted: Int
  profitTarget: Float
  lessonsCompleted: Int
}

type QuestStartResult {
  success: Boolean!
  quest: Quest!
  progress: QuestProgress!
  message: String!
}

type QuestAbandonResult {
  success: Boolean!
  xpLost: Int!
  streakImpact: Boolean!
  message: String!
}

# Simulation Types

type SimSession {
  id: ID!
  userId: ID!
  symbol: String!
  mode: String!  # "paper", "demo", "practice"
  startTime: DateTime!
  endTime: DateTime
  initialBalance: Float!
  currentBalance: Float!
  tradesExecuted: [SimTrade!]!
  learningObjectives: [String!]!
  voiceFeedbackEnabled: Boolean!
  regimeContext: String!
  isActive: Boolean!
  performanceMetrics: SimPerformanceMetrics!
}

type SimTrade {
  id: ID!
  timestamp: DateTime!
  symbol: String!
  side: String!  # "BUY", "SELL"
  quantity: Int!
  price: Float!
  pnl: Float!
  commission: Float!
  slippage: Float!
  tradeData: String!  # JSON string
}

type SimPerformanceMetrics {
  totalTrades: Int!
  winningTrades: Int!
  losingTrades: Int!
  winRate: Float!
  averageWin: Float!
  averageLoss: Float!
  profitFactor: Float!
  maxDrawdown: Float!
  sharpeRatio: Float!
  totalPnL: Float!
  returnPercentage: Float!
}

type SimTradeResult {
  success: Boolean!
  trade: SimTrade!
  feedback: String!
  xpEarned: Int!
  newBalance: Float!
  learningObjectivesProgress: [ObjectiveProgress!]!
  performanceUpdate: SimPerformanceMetrics!
  voiceFeedback: String!
}

type ObjectiveProgress {
  objective: String!
  progress: Float!
  isCompleted: Boolean!
  completionTime: DateTime
}

type SimSessionResult {
  session: SimSession!
  finalPerformance: SimPerformanceMetrics!
  achievements: [String!]!
  xpEarned: Int!
  badgesEarned: [String!]!
  recommendations: [String!]!
}

input SimTradeInput {
  symbol: String!
  side: String!
  quantity: Int!
  orderType: String!  # "MARKET", "LIMIT"
  limitPrice: Float
  stopPrice: Float
  timeInForce: String!  # "DAY", "GTC", "IOC", "FOK"
}

# Badge Types

type Badge {
  id: ID!
  name: String!
  description: String!
  iconUrl: String!
  rarity: String!  # "Common", "Rare", "Epic", "Legendary"
  category: String!
  xpReward: Int!
  isEarned: Boolean!
  earnedAt: DateTime
  progress: Float!  # 0.0 to 1.0 for progress badges
}

type BadgeClaimResult {
  success: Boolean!
  badge: Badge!
  xpEarned: Int!
  message: String!
}

# Voice Integration Types

type VoiceCommandResult {
  success: Boolean!
  command: String!
  parsedIntent: String!
  response: String!
  voiceNarration: String!
  actions: [VoiceAction!]!
  confidence: Float!
}

type VoiceAction {
  type: String!  # "start_lesson", "submit_answer", "request_explanation", etc.
  parameters: String!  # JSON string
  executed: Boolean!
  result: String!
}

type VoicePreferenceResult {
  success: Boolean!
  voiceId: String!
  voiceName: String!
  message: String!
}

# Community Types

type CircleLeague {
  id: ID!
  name: String!
  description: String!
  memberCount: Int!
  averageLevel: Float!
  topPerformers: [LeagueEntry!]!
  weeklyChallenges: [String!]!
  isPrivate: Boolean!
  joinRequirements: String!
}

type LeagueJoinResult {
  success: Boolean!
  league: CircleLeague!
  message: String!
  initialRank: Int!
}

type ShareResult {
  success: Boolean!
  sharedTo: [String!]!
  message: String!
  xpBonus: Int!
}

type ChallengeResult {
  success: Boolean!
  challengeId: ID!
  challengeType: String!
  opponent: String!
  message: String!
  xpReward: Int!
}

# Scalar Types
scalar DateTime
