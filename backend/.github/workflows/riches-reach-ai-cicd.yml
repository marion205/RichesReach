name: RichesReach AI CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - 'mobile/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - 'mobile/**'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: riches-reach-ai
  ECS_CLUSTER: riches-reach-ai-production-cluster
  ECS_SERVICE: riches-reach-ai-ai
  ECS_TASK_DEFINITION: riches-reach-ai-task

jobs:
  # Test and Lint
  test:
    name: Test and Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements-production.txt
          pip install pytest pytest-asyncio flake8 black
      - name: Run linting
        run: |
          cd backend
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          black --check .
      - name: Run tests
        run: |
          cd backend
          python -m pytest tests/ -v --tb=short
      - name: Test ML services
        run: |
          cd backend
          python -c "
          try:
              from core.optimized_ml_service import OptimizedMLService
              from core.market_data_service import MarketDataService
              print('SUCCESS: ML services import successfully')
          except ImportError as e:
              print(f'ERROR: ML service import failed: {e}')
              exit(1)
          "

  # Build and Test Docker Image
  build:
    name: Build and Test Docker Image
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Build Docker image
        run: |
          docker build -f backend/backend/Dockerfile.production -t riches-reach-ai:test .
      - name: Test Docker image
        run: |
          docker run --rm -d --name test-container -p 8000:8000 riches-reach-ai:test
          sleep 10
          curl -f http://localhost:8000/health || exit 1
          docker stop test-container
      - name: URL smoke test (in container)
        run: |
          docker run --rm -e DJANGO_SETTINGS_MODULE=richesreach.settings_production riches-reach-ai:test \
          python - <<'PY'
          import os
          os.environ.setdefault("DJANGO_SETTINGS_MODULE","richesreach.settings_production")
          import django; django.setup()
          from django.urls import resolve, Resolver404
          def check(path):
              try:
                  print(path, "->", resolve(path).url_name or "OK")
              except Resolver404:
                  raise SystemExit(f"404 (resolver): {path}")
          for p in [
            "/api/tax/optimization-summary/",
            "/api/tax/loss-harvesting/",
            "/api/tax/smart-lot-optimizer-v2/",
            "/api/tax/two-year-gains-planner/",
            "/api/tax/wash-sale-guard-v2/",
          ]:
              check(p)
          print("URL smoke OK")
          PY

  # Security Scan
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Deploy to Staging (on develop branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [test, build, security]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/backend/Dockerfile.production -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: backend/backend/task-definition-staging.json
          service: ${{ env.ECS_SERVICE }}-staging
          cluster: ${{ env.ECS_CLUSTER }}-staging
          wait-for-service-stability: true

  # Deploy to Production (on main branch)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, build, security]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/backend/Dockerfile.production -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
      - name: Render task definition with new image
        run: |
          IMAGE=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          jq --arg IMG "$IMAGE" '.containerDefinitions[0].image = $IMG' backend/backend/task-definition-production.json > backend/backend/task-definition-rendered.json
      - name: Register task definition
        run: |
          aws ecs register-task-definition --cli-input-json file://backend/backend/task-definition-rendered.json
      - name: Update service (force new deployment)
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --wait-for-service-stability
      - name: Run smoke tests
        run: |
          # Wait for service to be ready
          sleep 60
          # Get load balancer DNS from CloudFormation
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name riches-reach-ai-production \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
            --output text)
          # Test health endpoint
          curl -f "http://$ALB_DNS/health" || exit 1
          # Test main endpoint
          curl -f "http://$ALB_DNS/" || exit 1
          echo "SUCCESS: Production deployment verified"
      - name: Notify deployment success
        if: success()
        run: |
          echo "SUCCESS: Production deployment completed successfully!"
          echo "Service URL: http://$ALB_DNS"
          echo "Monitor at: https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters/${{ env.ECS_CLUSTER }}/services"

  # Rollback on failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure() && github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Rollback ECS service
        run: |
          # Get previous task definition revision
          PREV_REVISION=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].deployments[?status==`PRIMARY`].taskDefinition' \
            --output text | cut -d'/' -f2 | cut -d':' -f2)
          # Rollback to previous revision
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_SERVICE }}:$PREV_REVISION \
            --region ${{ env.AWS_REGION }}
          echo "Rolled back to revision: $PREV_REVISION"
      - name: Notify rollback
        run: |
          echo "ERROR: Production deployment failed - service rolled back"
          echo "Check logs and fix issues before next deployment"# Trigger deployment - Fri Oct 10 12:19:07 EDT 2025
