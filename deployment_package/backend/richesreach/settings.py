"""
Django settings for richesreach project.
Generated by 'django-admin startproject' using Django 4.2.1.
For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/
For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""
from pathlib import Path
import os
from dotenv import load_dotenv
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
# Load environment variables from .env file (in backend directory)
env_path = BASE_DIR / '.env'
load_dotenv(env_path)
# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/
# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY', 'django-insecure-wk_qy339*l)1xg=(f6_e@9+d7sgi7%#0t!e17a3nkeu&p#@zq9')
# SECURITY WARNING: don't run with debug turned on in production!
# Get ALLOWED_HOSTS from env or use default
allowed_hosts_env = os.getenv('ALLOWED_HOSTS', '')
if allowed_hosts_env:
    ALLOWED_HOSTS = allowed_hosts_env.split(',')
else:
    ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '10.0.0.64', '192.168.1.151', '192.168.1.240', '0.0.0.0']

# Always add common local development IPs if not already present
local_ips = ['127.0.0.1', 'localhost', '192.168.1.240', '192.168.1.151', '0.0.0.0']
for ip in local_ips:
    if ip not in ALLOWED_HOSTS:
        ALLOWED_HOSTS.append(ip)

# Force DEBUG=True for local development
is_local = any(ip in ALLOWED_HOSTS for ip in ['127.0.0.1', 'localhost', '192.168.1.240', '192.168.1.151', '0.0.0.0'])
if is_local:
    DEBUG = True  # Always enable DEBUG for local development
else:
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
# Frontend URL for email links
FRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:3000')
# Feature Flags - Week 4 Beta Launch
ENABLE_HYBRID_ML_MODEL = os.getenv('ENABLE_HYBRID_ML_MODEL', 'true').lower() == 'true'
ENABLE_CONSUMER_STRENGTH_SCORE = os.getenv('ENABLE_CONSUMER_STRENGTH_SCORE', 'true').lower() == 'true'
ENABLE_SHAP_EXPLAINABILITY = os.getenv('ENABLE_SHAP_EXPLAINABILITY', 'true').lower() == 'true'

# Application definition
INSTALLED_APPS = [
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
'channels',
'core',
'graphene_django',
'corsheaders',
'django_celery_results',
]
MIDDLEWARE = [
'corsheaders.middleware.CorsMiddleware',
'django.middleware.security.SecurityMiddleware',
'django.contrib.sessions.middleware.SessionMiddleware',
'django.middleware.common.CommonMiddleware',
'core.rate_limiting.RateLimitMiddleware',  # Rate limiting
'django.middleware.csrf.CsrfViewMiddleware',
'django.contrib.auth.middleware.AuthenticationMiddleware',
'core.zero_trust_middleware.ZeroTrustMiddleware',  # Zero Trust Architecture
'django.contrib.messages.middleware.MessageMiddleware',
'django.middleware.clickjacking.XFrameOptionsMiddleware',
'core.performance_monitoring.PerformanceMonitoringMiddleware',  # Performance monitoring
]
ROOT_URLCONF = 'richesreach.urls'
TEMPLATES = [
{
'BACKEND': 'django.template.backends.django.DjangoTemplates',
'DIRS': [],
'APP_DIRS': True,
'OPTIONS': {
'context_processors': [
'django.template.context_processors.debug',
'django.template.context_processors.request',
'django.contrib.auth.context_processors.auth',
'django.contrib.messages.context_processors.messages',
],
},
},
]
WSGI_APPLICATION = 'richesreach.wsgi.application'
ASGI_APPLICATION = 'richesreach.asgi.application'
# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases
# Use DATABASE_URL if provided, otherwise use individual DB_* variables
DATABASE_URL = os.getenv('DATABASE_URL', '')
if DATABASE_URL:
    # Parse DATABASE_URL (format: postgresql://user:password@host:port/dbname or postgresql://user@host:port/dbname)
    import re
    # Try with password first
    match = re.match(r'postgresql://([^:]+):([^@]+)@([^:]+):(\d+)/(.+)', DATABASE_URL)
    if match:
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.postgresql',
                'NAME': match.group(5),
                'USER': match.group(1),
                'PASSWORD': match.group(2),
                'HOST': match.group(3),
                'PORT': match.group(4),
                # OPTIMIZATION: Connection pooling
                'CONN_MAX_AGE': 600,
                'OPTIONS': {
                    'connect_timeout': 10,
                },
            }
        }
    else:
        # Try without password (postgresql://user@host:port/dbname)
        match = re.match(r'postgresql://([^@]+)@([^:]+):(\d+)/(.+)', DATABASE_URL)
        if match:
            DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.postgresql',
                    'NAME': match.group(4),
                    'USER': match.group(1),
                    'PASSWORD': '',
                    'HOST': match.group(2),
                    'PORT': match.group(3),
                    # OPTIMIZATION: Connection pooling
                    'CONN_MAX_AGE': 600,
                    'OPTIONS': {
                        'connect_timeout': 10,
                    },
                }
            }
        else:
            # Fallback to SQLite if DATABASE_URL format is invalid
            DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.sqlite3',
                    'NAME': BASE_DIR / 'db.sqlite3',
                }
            }
else:
    # Use individual DB_* environment variables
    DB_NAME = os.getenv('DB_NAME', '')
    DB_USER = os.getenv('DB_USER', '')
    DB_PASSWORD = os.getenv('DB_PASSWORD', '')
    DB_HOST = os.getenv('DB_HOST', '')
    DB_PORT = os.getenv('DB_PORT', '5432')
    
    if DB_NAME and DB_USER and DB_HOST:
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.postgresql',
                'NAME': DB_NAME,
                'USER': DB_USER,
                'PASSWORD': DB_PASSWORD,
                'HOST': DB_HOST,
                'PORT': DB_PORT,
                # OPTIMIZATION: Connection pooling - reuse connections for 600 seconds (10 minutes)
                # This reduces connection overhead and improves performance under load
                'CONN_MAX_AGE': 600,
                'OPTIONS': {
                    'connect_timeout': 10,
                },
            }
        }
    else:
        # Fallback to SQLite for development
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': BASE_DIR / 'db.sqlite3',
            }
        }
# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = os.getenv('EMAIL_HOST', 'smtp.gmail.com')
EMAIL_PORT = int(os.getenv('EMAIL_PORT', '587'))
EMAIL_USE_TLS = os.getenv('EMAIL_USE_TLS', 'True').lower() == 'true'
EMAIL_USE_SSL = False # Disable SSL for local development
EMAIL_SSL_CERTFILE = '' # No SSL certificate file
EMAIL_SSL_KEYFILE = '' # No SSL key file
# Email SSL verification - production-safe
EMAIL_SSL_CHECK_HOSTNAME = os.getenv('EMAIL_SSL_CHECK_HOSTNAME', 'true').lower() == 'true'
if os.getenv('ENVIRONMENT', '').lower() == 'production' and not EMAIL_SSL_CHECK_HOSTNAME:
    raise ValueError("EMAIL_SSL_CHECK_HOSTNAME cannot be False in production")
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER', '')
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD', '')
DEFAULT_FROM_EMAIL = os.getenv('DEFAULT_FROM_EMAIL', 'noreply@richesreach.com')
# Cache Configuration (for rate limiting and tokens)
CACHES = {
'default': {
'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
'LOCATION': 'unique-snowflake',
}
}
# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
{
'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
},
{
'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
},
{
'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
},
{
'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
},
]
# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/
STATIC_URL = 'static/'
# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
CORS_ALLOW_ALL_ORIGINS = True # For dev only

# Security Settings (Production)
# Check if we're in local development (DEBUG mode or local IPs)
is_local_dev = DEBUG or any(ip in ALLOWED_HOSTS for ip in ['127.0.0.1', 'localhost', '192.168.1.240', '192.168.1.151', '0.0.0.0'])

# Only enable SSL redirect if not in development
if not is_local_dev:
    SECURE_SSL_REDIRECT = os.getenv('SECURE_SSL_REDIRECT', 'True').lower() == 'true'
    SESSION_COOKIE_SECURE = os.getenv('SESSION_COOKIE_SECURE', 'True').lower() == 'true'
    CSRF_COOKIE_SECURE = os.getenv('CSRF_COOKIE_SECURE', 'True').lower() == 'true'
    SECURE_HSTS_SECONDS = int(os.getenv('SECURE_HSTS_SECONDS', '31536000'))
    SECURE_HSTS_INCLUDE_SUBDOMAINS = os.getenv('SECURE_HSTS_INCLUDE_SUBDOMAINS', 'True').lower() == 'true'
    SECURE_HSTS_PRELOAD = os.getenv('SECURE_HSTS_PRELOAD', 'True').lower() == 'true'
else:
    # Development settings - disable SSL redirect for local development
    SECURE_SSL_REDIRECT = False
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    SECURE_HSTS_SECONDS = 0
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False
# Build GRAPHENE middleware list - make graphql_jwt optional
graphene_middleware = [
    "graphene_django.debug.DjangoDebugMiddleware",  # Add debug middleware for better error handling
]
try:
    import graphql_jwt
    graphene_middleware.append("graphql_jwt.middleware.JSONWebTokenMiddleware")
except ImportError:
    # graphql_jwt is optional - continue without it
    pass

GRAPHENE = {
"SCHEMA": "core.schema.schema",
"MIDDLEWARE": graphene_middleware,
"SCHEMA_INDEPTH_LIMIT": 20,
"SCHEMA_OUTPUT": "schema.json",
}
AUTH_USER_MODEL = "core.User"
# Authentication backends
AUTHENTICATION_BACKENDS = [
'graphql_jwt.backends.JSONWebTokenBackend',
'django.contrib.auth.backends.ModelBackend',
]
# OpenAI Configuration
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY') # Set this in environment variable OPENAI_API_KEY
OPENAI_MODEL = "gpt-4o-mini" # Default model to use (cheaper & faster than gpt-3.5-turbo now)
OPENAI_MAX_TOKENS = 1000 # Maximum tokens for responses
OPENAI_TEMPERATURE = 0.7 # Temperature for responses (0.0-2.0)
OPENAI_TIMEOUT_S = 15.0 # Request timeout in seconds
OPENAI_MAX_RETRIES = 2 # Maximum retries on transient errors
OPENAI_MAX_CONCURRENCY = 10 # Maximum concurrent OpenAI calls (async only)
OPENAI_MAX_HISTORY = 20 # Maximum message history to include in prompts

# Google Gemini Configuration (Hybrid AI Architecture)
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY') # Set this in environment variable GEMINI_API_KEY
GEMINI_MODEL = "gemini-1.5-pro" # Use "gemini-1.5-flash" for faster responses
GEMINI_MAX_OUTPUT_TOKENS = 8192 # Maximum output tokens (Gemini supports large contexts)
GEMINI_TEMPERATURE = 0.7 # Temperature for responses (0.0-2.0)
GEMINI_TIMEOUT_S = 30.0 # Longer timeout for large documents
GEMINI_MAX_RETRIES = 2 # Maximum retries on transient errors
GEMINI_MAX_CONCURRENCY = 5 # Lower than ChatGPT (Gemini can be slower for large docs)

# Hybrid AI Orchestrator Configuration
ENABLE_HYBRID_AI_ROUTING = os.getenv('ENABLE_HYBRID_AI_ROUTING', 'true').lower() == 'true'
ENABLE_PII_SCRUBBING = os.getenv('ENABLE_PII_SCRUBBING', 'true').lower() == 'true'
ENABLE_AI_FUNCTION_CALLING = os.getenv('ENABLE_AI_FUNCTION_CALLING', 'true').lower() == 'true'  # Enable LLM function calling (tools)
ENABLE_AUDIT_TRAIL = os.getenv('ENABLE_AUDIT_TRAIL', 'true').lower() == 'true'  # Enable audit trail logging for compliance
DEFAULT_AI_MODEL = os.getenv('DEFAULT_AI_MODEL', 'chatgpt') # Fallback model: 'chatgpt' or 'gemini'

# AI rate limiting
AI_RATE_LIMIT_PER_USER = 30 # Requests per user per minute
AI_RATE_LIMIT_WINDOW_S = 60 # Rate limit window in seconds
# Market data cache TTL (seconds)
MARKET_REGIME_CACHE_TTL_S = 60 # Cache market regime indicators for 60 seconds
# AlphaVantage API Configuration
ALPHA_VANTAGE_API_KEY = os.getenv('ALPHA_VANTAGE_API_KEY')
if not ALPHA_VANTAGE_API_KEY:
    print("WARNING: ALPHA_VANTAGE_API_KEY not set. Stock price data will not be available.")
# Redis Configuration for Caching
REDIS_HOST = os.getenv('REDIS_HOST', 'localhost')
REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
REDIS_DB = int(os.getenv('REDIS_DB', 0))
REDIS_PASSWORD = os.getenv('REDIS_PASSWORD', None)
# Cache Configuration
CACHES = {
'default': {
'BACKEND': 'django_redis.cache.RedisCache',
'LOCATION': f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}',
'OPTIONS': {
'CLIENT_CLASS': 'django_redis.client.DefaultClient',
'PASSWORD': REDIS_PASSWORD,
'SOCKET_CONNECT_TIMEOUT': 5,
'SOCKET_TIMEOUT': 5,
},
'KEY_PREFIX': 'richesreach',
'TIMEOUT': 300, # 5 minutes default
},
}
# Use Redis for session storage as well
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'
# Stock Analysis Configuration
STOCK_ANALYSIS_CONFIG = {
'CACHE_TIMEOUT': {
'QUOTE_DATA': 300, # 5 minutes for real-time quotes
'OVERVIEW_DATA': 3600, # 1 hour for company overview
'HISTORICAL_DATA': 86400, # 24 hours for historical data
'ANALYSIS_RESULT': 1800, # 30 minutes for analysis results
},
'RATE_LIMITS': {
'ALPHA_VANTAGE': {
'REQUESTS_PER_MINUTE': 5,
'REQUESTS_PER_DAY': 500,
'BURST_LIMIT': 10,
}
},
'BATCH_PROCESSING': {
'MAX_STOCKS_PER_BATCH': 10,
'BATCH_DELAY_SECONDS': 2,
'MAX_CONCURRENT_BATCHES': 3,
}
}
# Celery Configuration
CELERY_BROKER_URL = f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'
CELERY_RESULT_BACKEND = f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'

# Monitoring & Error Tracking
# Initialize Sentry if DSN is provided
try:
    from core.monitoring_setup import init_monitoring
    init_monitoring()
except Exception as e:
    print(f"Warning: Could not initialize monitoring: {e}")

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
        'json': {
            'format': '{levelname} {asctime} {name} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': os.getenv('LOG_LEVEL', 'INFO'),
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': os.getenv('DJANGO_LOG_LEVEL', 'INFO'),
            'propagate': False,
        },
        'core': {
            'handlers': ['console'],
            'level': os.getenv('CORE_LOG_LEVEL', 'INFO'),
            'propagate': False,
        },
    },
}
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE
# Celery Beat Schedule
CELERY_BEAT_SCHEDULE = {
'update-stock-data': {
'task': 'core.stock_service.update_stock_data_periodic',
'schedule': 3600.0, # Every hour
},
'cleanup-old-cache': {
'task': 'core.stock_service.cleanup_old_cache',
'schedule': 86400.0, # Every day
},
}
# Channels Configuration
CHANNEL_LAYERS = {
'default': {
'BACKEND': 'channels_redis.core.RedisChannelLayer',
'CONFIG': {
"hosts": [f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'],
},
},
}