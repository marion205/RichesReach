"""
Signal Performance Models - Citadel-grade tracking for day trading picks
Tracks every pick, its features, and realized PnL over time
"""
from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone
from decimal import Decimal
import uuid
import json

User = get_user_model()


class DayTradingSignal(models.Model):
    """
    Records every day trading pick generated by the system.
    This is the "input" - what we recommended at time T.
    """
    MODE_CHOICES = [
        ('SAFE', 'Safe'),
        ('AGGRESSIVE', 'Aggressive'),
    ]
    
    SIDE_CHOICES = [
        ('LONG', 'Long'),
        ('SHORT', 'Short'),
    ]
    
    # Signal metadata
    signal_id = models.UUIDField(unique=True, default=None, editable=False)
    generated_at = models.DateTimeField(default=timezone.now, db_index=True)
    mode = models.CharField(max_length=10, choices=MODE_CHOICES, db_index=True)
    universe_source = models.CharField(
        max_length=20,
        default='CORE',
        choices=[('CORE', 'Core Universe'), ('DYNAMIC_MOVERS', 'Dynamic Movers')],
        db_index=True,
        help_text='Source of the stock universe (CORE = static, DYNAMIC_MOVERS = Polygon top movers)'
    )
    
    # Stock info
    symbol = models.CharField(max_length=10, db_index=True)
    side = models.CharField(max_length=5, choices=SIDE_CHOICES)
    
    # Features at time of signal (what we used to pick it)
    features = models.JSONField(default=dict)  # momentum15m, rvol10m, vwapDist, etc.
    
    # Signal quality
    score = models.DecimalField(max_digits=10, decimal_places=4)
    
    # Entry/exit parameters
    entry_price = models.DecimalField(max_digits=10, decimal_places=2)
    stop_price = models.DecimalField(max_digits=10, decimal_places=2)
    target_prices = models.JSONField(default=list)  # [target1, target2]
    time_stop_minutes = models.IntegerField()
    
    # Risk parameters
    atr_5m = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    suggested_size_shares = models.IntegerField(default=100)
    risk_per_trade_pct = models.DecimalField(max_digits=5, decimal_places=3)  # 0.5% for SAFE, 1.2% for AGGRESSIVE
    
    # Notes
    notes = models.TextField(blank=True)
    
    class Meta:
        db_table = 'day_trading_signals'
        ordering = ['-generated_at']
        indexes = [
            models.Index(fields=['generated_at', 'mode']),
            models.Index(fields=['symbol', 'generated_at']),
            models.Index(fields=['mode', 'score']),
        ]
        verbose_name = 'Day Trading Signal'
        verbose_name_plural = 'Day Trading Signals'
    
    def __str__(self):
        return f"{self.symbol} {self.side} ({self.mode}) - {self.generated_at.strftime('%Y-%m-%d %H:%M')}"
    
    def save(self, *args, **kwargs):
        if not self.signal_id:
            import uuid
            self.signal_id = uuid.uuid4()
        super().save(*args, **kwargs)


class SwingTradingSignal(models.Model):
    """
    Records every swing trading pick generated by the system (2-5 day holds).
    Similar to DayTradingSignal but for longer timeframes.
    """
    STRATEGY_CHOICES = [
        ('MOMENTUM', 'Swing Momentum'),
        ('BREAKOUT', 'Swing Breakout'),
        ('MEAN_REVERSION', 'Swing Mean Reversion'),
    ]
    
    SIDE_CHOICES = [
        ('LONG', 'Long'),
        ('SHORT', 'Short'),
    ]
    
    # Signal metadata
    signal_id = models.UUIDField(unique=True, default=None, editable=False)
    generated_at = models.DateTimeField(default=timezone.now, db_index=True)
    strategy = models.CharField(max_length=20, choices=STRATEGY_CHOICES, db_index=True)
    universe_source = models.CharField(
        max_length=20,
        default='CORE',
        choices=[('CORE', 'Core Universe'), ('DYNAMIC_MOVERS', 'Dynamic Movers'), ('ETF', 'ETF Universe')],
        db_index=True,
    )
    
    # Stock info
    symbol = models.CharField(max_length=10, db_index=True)
    side = models.CharField(max_length=5, choices=SIDE_CHOICES)
    
    # Features at time of signal
    features = models.JSONField(default=dict)  # momentum1d, rvol5d, breakoutStrength, etc.
    
    # Signal quality
    score = models.DecimalField(max_digits=10, decimal_places=4)
    
    # Entry/exit parameters
    entry_price = models.DecimalField(max_digits=10, decimal_places=2)
    stop_price = models.DecimalField(max_digits=10, decimal_places=2)
    target_prices = models.JSONField(default=list)  # [target1, target2]
    hold_days = models.IntegerField(default=3)  # Expected hold period (2-5 days)
    
    # Risk parameters
    atr_1d = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    suggested_size_shares = models.IntegerField(default=100)
    risk_per_trade_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('1.00'))  # 1% default
    
    # Notes
    notes = models.TextField(blank=True)
    
    class Meta:
        db_table = 'swing_trading_signals'
        ordering = ['-generated_at']
        indexes = [
            models.Index(fields=['generated_at', 'strategy']),
            models.Index(fields=['symbol', 'generated_at']),
            models.Index(fields=['strategy', 'score']),
        ]
        verbose_name = 'Swing Trading Signal'
        verbose_name_plural = 'Swing Trading Signals'
    
    def __str__(self):
        return f"{self.symbol} {self.side} ({self.strategy}) - {self.generated_at.strftime('%Y-%m-%d')}"
    
    def save(self, *args, **kwargs):
        if not self.signal_id:
            import uuid
            self.signal_id = uuid.uuid4()
        super().save(*args, **kwargs)


class SignalPerformance(models.Model):
    """
    Tracks realized performance of signals at different time horizons.
    This is the "output" - what actually happened.
    """
    HORIZON_CHOICES = [
        ('30m', '30 Minutes'),
        ('2h', '2 Hours'),
        ('EOD', 'End of Day'),
        ('1d', '1 Day'),
        ('2d', '2 Days'),
        ('3d', '3 Days'),
        ('5d', '5 Days'),
        ('7d', '7 Days'),
    ]
    
    signal = models.ForeignKey(DayTradingSignal, on_delete=models.CASCADE, related_name='performance', null=True, blank=True)
    swing_signal = models.ForeignKey(SwingTradingSignal, on_delete=models.CASCADE, related_name='performance', null=True, blank=True)
    
    # Ensure at least one signal is set
    def clean(self):
        if not self.signal and not self.swing_signal:
            raise ValueError("Either signal or swing_signal must be set")
        if self.signal and self.swing_signal:
            raise ValueError("Cannot set both signal and swing_signal")
    
    # Time horizon
    horizon = models.CharField(max_length=5, choices=HORIZON_CHOICES, db_index=True)
    evaluated_at = models.DateTimeField(default=timezone.now, db_index=True)
    
    # Price at evaluation time
    price_at_horizon = models.DecimalField(max_digits=10, decimal_places=2)
    
    # PnL calculations
    pnl_dollars = models.DecimalField(max_digits=15, decimal_places=2)
    pnl_percent = models.DecimalField(max_digits=10, decimal_places=4)
    
    # Did it hit stop or target?
    hit_stop = models.BooleanField(default=False)
    hit_target_1 = models.BooleanField(default=False)
    hit_target_2 = models.BooleanField(default=False)
    hit_time_stop = models.BooleanField(default=False)
    
    # Outcome classification
    outcome = models.CharField(max_length=20)  # 'WIN', 'LOSS', 'BREAKEVEN', 'STOP_HIT', 'TARGET_HIT'
    
    # Risk metrics
    max_favorable_excursion = models.DecimalField(max_digits=10, decimal_places=4, null=True)  # Best price reached
    max_adverse_excursion = models.DecimalField(max_digits=10, decimal_places=4, null=True)  # Worst price reached
    
    class Meta:
        db_table = 'signal_performance'
        ordering = ['-evaluated_at']
        indexes = [
            models.Index(fields=['signal', 'horizon']),
            models.Index(fields=['horizon', 'outcome']),
            models.Index(fields=['evaluated_at']),
        ]
        unique_together = [('signal', 'horizon'), ('swing_signal', 'horizon')]  # One performance record per signal per horizon
        verbose_name = 'Signal Performance'
        verbose_name_plural = 'Signal Performances'
    
    def __str__(self):
        symbol = self.signal.symbol if self.signal else (self.swing_signal.symbol if self.swing_signal else 'UNKNOWN')
        return f"{symbol} {self.horizon} - {self.outcome} ({self.pnl_percent:.2f}%)"


class StrategyPerformance(models.Model):
    """
    Aggregated performance stats for each mode (SAFE/AGGRESSIVE) over time periods.
    This is the "Citadel Board" - your Sharpe, win rate, max DD, etc.
    """
    MODE_CHOICES = [
        ('SAFE', 'Safe'),
        ('AGGRESSIVE', 'Aggressive'),
    ]
    
    PERIOD_CHOICES = [
        ('DAILY', 'Daily'),
        ('WEEKLY', 'Weekly'),
        ('MONTHLY', 'Monthly'),
        ('ALL_TIME', 'All Time'),
    ]
    
    mode = models.CharField(max_length=10, choices=MODE_CHOICES, db_index=True)
    period = models.CharField(max_length=10, choices=PERIOD_CHOICES, db_index=True)
    period_start = models.DateTimeField(db_index=True)
    period_end = models.DateTimeField(db_index=True)
    
    # Signal counts
    total_signals = models.IntegerField(default=0)
    signals_evaluated = models.IntegerField(default=0)
    
    # Win/Loss stats
    winning_signals = models.IntegerField(default=0)
    losing_signals = models.IntegerField(default=0)
    breakeven_signals = models.IntegerField(default=0)
    win_rate = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    
    # PnL stats
    total_pnl_dollars = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    total_pnl_percent = models.DecimalField(max_digits=10, decimal_places=4, default=Decimal('0.00'))
    avg_pnl_per_signal = models.DecimalField(max_digits=10, decimal_places=4, default=Decimal('0.00'))
    
    # Risk metrics
    sharpe_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    max_drawdown = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    max_drawdown_duration_days = models.IntegerField(null=True)
    
    # Risk-adjusted returns
    sortino_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    calmar_ratio = models.DecimalField(max_digits=10, decimal_places=4, null=True)  # Return / Max DD
    
    # Tail risk
    worst_single_loss = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    best_single_win = models.DecimalField(max_digits=10, decimal_places=4, null=True)
    
    # Equity curve data (stored as JSON array of {date, equity} points)
    equity_curve = models.JSONField(default=list, blank=True)
    
    # Metadata
    calculated_at = models.DateTimeField(default=timezone.now)
    notes = models.TextField(blank=True)
    
    class Meta:
        db_table = 'strategy_performance'
        ordering = ['-period_end', '-mode']
        indexes = [
            models.Index(fields=['mode', 'period', 'period_end']),
            models.Index(fields=['calculated_at']),
        ]
        unique_together = ['mode', 'period', 'period_start', 'period_end']
        verbose_name = 'Strategy Performance'
        verbose_name_plural = 'Strategy Performances'
    
    def __str__(self):
        return f"{self.mode} {self.period} - Sharpe: {self.sharpe_ratio or 0:.2f}, Win Rate: {self.win_rate:.1f}%"


class StrategyGovernance(models.Model):
    """
    Persisted Investment Committee status for a specific strategy performance period.
    """
    STATUS_CHOICES = [
        ('ACTIVE', 'Active - Meeting all KPIs'),
        ('WATCH', 'Watch - Below target but above minimum'),
        ('REVIEW', 'Review Required - Below minimum thresholds'),
        ('PAUSED', 'Paused - Temporarily disabled'),
        ('RETIRED', 'Retired - Permanently disabled'),
    ]

    strategy_performance = models.OneToOneField(
        StrategyPerformance,
        on_delete=models.CASCADE,
        related_name='governance_status',
    )
    mode = models.CharField(max_length=10, db_index=True)
    period = models.CharField(max_length=10, db_index=True)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, db_index=True)
    score = models.FloatField(default=0.0)
    issues = models.JSONField(default=list, blank=True)
    recommendations = models.JSONField(default=list, blank=True)
    kpi_status = models.JSONField(default=dict, blank=True)
    insufficient_data = models.BooleanField(default=False)
    report = models.TextField(blank=True)
    evaluated_at = models.DateTimeField(default=timezone.now, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'strategy_governance'
        ordering = ['-evaluated_at']
        indexes = [
            models.Index(fields=['mode', 'period', 'evaluated_at']),
            models.Index(fields=['status']),
        ]
        verbose_name = 'Strategy Governance'
        verbose_name_plural = 'Strategy Governance'

    def __str__(self):
        return f"{self.mode} {self.period} - {self.status} ({self.score:.1f})"


class UserRiskBudget(models.Model):
    """
    Per-user risk management - tracks daily/weekly risk budgets and circuit breakers.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='risk_budget')
    
    # Account info
    account_value = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    
    # Daily risk limits
    max_daily_risk_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('2.00'))  # 2% max risk per day
    daily_risk_used_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('0.00'))
    daily_risk_reset_date = models.DateField(default=timezone.now)
    
    # Weekly risk limits
    max_weekly_risk_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('5.00'))  # 5% max risk per week
    weekly_risk_used_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('0.00'))
    weekly_risk_reset_date = models.DateField(default=timezone.now)
    
    # Circuit breakers
    max_daily_loss_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('3.00'))  # -3% = pause trading
    daily_pnl_pct = models.DecimalField(max_digits=10, decimal_places=4, default=Decimal('0.00'))
    trading_paused = models.BooleanField(default=False)
    trading_paused_until = models.DateTimeField(null=True, blank=True)
    pause_reason = models.TextField(blank=True)
    
    # Position sizing rules
    max_position_size_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('10.00'))  # Max 10% in one position
    min_position_size_pct = models.DecimalField(max_digits=5, decimal_places=3, default=Decimal('1.00'))  # Min 1% position
    
    # Volatility-based sizing
    use_volatility_sizing = models.BooleanField(default=True)
    volatility_lookback_days = models.IntegerField(default=20)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'user_risk_budgets'
        verbose_name = 'User Risk Budget'
        verbose_name_plural = 'User Risk Budgets'
    
    def __str__(self):
        return f"{self.user.email} - Risk Budget (Daily: {self.daily_risk_used_pct:.2f}% / {self.max_daily_risk_pct:.2f}%)"
    
    def reset_daily_risk(self):
        """Reset daily risk counters"""
        from django.utils import timezone
        today = timezone.now().date()
        if self.daily_risk_reset_date < today:
            self.daily_risk_used_pct = Decimal('0.00')
            self.daily_pnl_pct = Decimal('0.00')
            self.daily_risk_reset_date = today
            if self.trading_paused and self.trading_paused_until:
                if timezone.now() > self.trading_paused_until:
                    self.trading_paused = False
                    self.trading_paused_until = None
                    self.pause_reason = ""
            self.save()
    
    def check_circuit_breaker(self):
        """Check if circuit breaker should trigger"""
        from django.utils import timezone
        self.reset_daily_risk()

        if self.daily_pnl_pct <= -abs(self.max_daily_loss_pct):
            if not self.trading_paused:
                self.trading_paused = True
                self.trading_paused_until = timezone.now() + timezone.timedelta(hours=24)  # Pause until tomorrow
                self.pause_reason = f"Daily loss limit hit: {self.daily_pnl_pct:.2f}%"
                self.save()
                return True
        return False


class UserFill(models.Model):
    """
    Records actual user fills (entry/exit) for trading signals.
    Separates real execution data from theoretical SignalPerformance evaluations.
    """
    OUTCOME_CHOICES = [
        ('WIN', 'Win'),
        ('LOSS', 'Loss'),
        ('BREAKEVEN', 'Breakeven'),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='fills')
    signal = models.ForeignKey(
        DayTradingSignal, on_delete=models.CASCADE,
        related_name='user_fills', null=True, blank=True
    )
    swing_signal = models.ForeignKey(
        SwingTradingSignal, on_delete=models.CASCADE,
        related_name='user_fills', null=True, blank=True
    )

    symbol = models.CharField(max_length=10, db_index=True)
    side = models.CharField(max_length=5)  # LONG/SHORT
    entry_price = models.DecimalField(max_digits=10, decimal_places=2)
    exit_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    entry_time = models.DateTimeField()
    exit_time = models.DateTimeField(null=True, blank=True)
    shares = models.IntegerField(default=100)

    # Computed on save
    pnl_dollars = models.DecimalField(max_digits=15, decimal_places=2, null=True, blank=True)
    pnl_percent = models.DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)

    # Execution quality (computed by ExecutionQualityTracker)
    slippage_bps = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    execution_quality_score = models.DecimalField(max_digits=5, decimal_places=1, null=True, blank=True)

    # Outcome
    outcome = models.CharField(max_length=20, choices=OUTCOME_CHOICES, blank=True)
    hit_stop = models.BooleanField(default=False)
    hit_target = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'user_fills'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['signal', 'user']),
            models.Index(fields=['symbol', 'created_at']),
        ]
        verbose_name = 'User Fill'
        verbose_name_plural = 'User Fills'

    def __str__(self):
        return f"{self.user_id} {self.symbol} {self.side} @ {self.entry_price}"

    def save(self, *args, **kwargs):
        # Auto-compute PnL if both entry and exit prices are set
        if self.entry_price and self.exit_price:
            if self.side == 'LONG':
                self.pnl_dollars = (self.exit_price - self.entry_price) * self.shares
                self.pnl_percent = ((self.exit_price - self.entry_price) / self.entry_price) * 100
            else:  # SHORT
                self.pnl_dollars = (self.entry_price - self.exit_price) * self.shares
                self.pnl_percent = ((self.entry_price - self.exit_price) / self.entry_price) * 100

            # Auto-determine outcome if not set
            if not self.outcome:
                if self.pnl_percent > Decimal('0.1'):
                    self.outcome = 'WIN'
                elif self.pnl_percent < Decimal('-0.1'):
                    self.outcome = 'LOSS'
                else:
                    self.outcome = 'BREAKEVEN'
        super().save(*args, **kwargs)


class SymbolExecutionProfile(models.Model):
    """
    Aggregated execution quality per symbol.
    Updated daily from UserFill data. Used to penalize signals
    for symbols with historically poor execution.
    """
    symbol = models.CharField(max_length=10, unique=True, db_index=True)
    avg_slippage_bps = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0'))
    avg_quality_score = models.DecimalField(max_digits=5, decimal_places=1, default=Decimal('5.0'))
    fill_count = models.IntegerField(default=0)
    avg_time_to_fill_seconds = models.FloatField(default=0)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'symbol_execution_profiles'
        verbose_name = 'Symbol Execution Profile'
        verbose_name_plural = 'Symbol Execution Profiles'

    def __str__(self):
        return f"{self.symbol} - quality={self.avg_quality_score}, fills={self.fill_count}"


class StrategyHealthRecord(models.Model):
    """
    Tracks consecutive pass/fail for strategies to trigger adaptation.
    Updated nightly after backtests complete.
    """
    strategy_name = models.CharField(max_length=100, unique=True, db_index=True)
    consecutive_failures = models.IntegerField(default=0)
    consecutive_passes = models.IntegerField(default=0)
    last_backtest_date = models.DateField(null=True, blank=True)
    last_backtest_passed = models.BooleanField(default=True)
    auto_disabled = models.BooleanField(default=False)
    auto_disabled_at = models.DateTimeField(null=True, blank=True)
    last_optimization_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'strategy_health_records'
        verbose_name = 'Strategy Health Record'
        verbose_name_plural = 'Strategy Health Records'

    def __str__(self):
        status = "DISABLED" if self.auto_disabled else "ACTIVE"
        return f"{self.strategy_name} [{status}] - passes={self.consecutive_passes}, fails={self.consecutive_failures}"

