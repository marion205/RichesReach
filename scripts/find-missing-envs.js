#!/usr/bin/env node
/**
 * find-missing-envs.js
 * Scans the repo for environment variable usages (process.env / Expo public vars)
 * and prints any keys not present in .env files or environment_template.env.
 *
 * Usage:
 *   node scripts/find-missing-envs.js
 */
const fs = require('fs');
const path = require('path');

// Alias suggestions (prefer Expo public keys on mobile)
const ALIASES = {
  WS_URL: 'EXPO_PUBLIC_WS_URL',
  SIGNAL_URL: 'EXPO_PUBLIC_SIGNAL_URL',
  API_BASE_URL: 'EXPO_PUBLIC_API_BASE_URL',
  TURN_URLS: 'EXPO_PUBLIC_TURN_URLS',
  TURN_USERNAME: 'EXPO_PUBLIC_TURN_USERNAME',
  TURN_CREDENTIAL: 'EXPO_PUBLIC_TURN_CREDENTIAL',
};
const suggestAlias = (k) => (ALIASES[k] ? ` (consider ${ALIASES[k]})` : '');

const REPO_ROOT = process.cwd();
const SEARCH_EXTS = new Set(['.ts', '.tsx', '.js', '.jsx', '.json', '.py', '.yaml', '.yml']);
const IGNORE = new Set(['node_modules', '.git', 'Pods', 'build', 'dist', '.next', '.expo', '.expo-shared', '.cache']);

function* walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (IGNORE.has(entry.name)) continue;
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) yield* walk(full);
    else yield full;
  }
}

function collectEnvKeys() {
  const keys = new Set();
  const reNode = /process\.env\.([A-Z0-9_]+)/g;
  const reExpo = /EXPO_PUBLIC_[A-Z0-9_]+/g;
  for (const file of walk(REPO_ROOT)) {
    const ext = path.extname(file);
    if (!SEARCH_EXTS.has(ext)) continue;
    let text = '';
    try { text = fs.readFileSync(file, 'utf8'); } catch { continue; }
    let m;
    while ((m = reNode.exec(text))) keys.add(m[1]);
    const expo = text.match(reExpo);
    if (expo) expo.forEach((k) => keys.add(k));
  }
  return keys;
}

function readEnvFile(file) {
  try {
    const txt = fs.readFileSync(file, 'utf8');
    const re = /^\s*([A-Z0-9_]+)\s*=/gm;
    const keys = new Set();
    let m;
    while ((m = re.exec(txt))) keys.add(m[1]);
    return keys;
  } catch {
    return new Set();
  }
}

function main() {
  const used = collectEnvKeys();
  const fromTemplate = readEnvFile(path.join(REPO_ROOT, 'environment_template.env'));
  const mobileEnv = readEnvFile(path.join(REPO_ROOT, 'mobile/.env'));
  const backendEnv = readEnvFile(path.join(REPO_ROOT, 'backend/.env'));

  const defined = new Set([...fromTemplate, ...mobileEnv, ...backendEnv]);
  const missing = [...used].filter((k) => !defined.has(k));

  console.log(`Found ${used.size} env keys referenced in code.`);
  if (missing.length === 0) {
    console.log('No missing env keys. âœ…');
    return;
  }
  console.log(`Missing ${missing.length} keys (not in environment_template.env, mobile/.env or backend/.env):`);
  missing.sort().forEach((k) => console.log(`  - ${k}=${suggestAlias(k)}`));

  const out = missing.map((k) => `${k}=`).join('\n') + '\n';
  const suggestionPath = path.join(REPO_ROOT, 'missing_env_keys.env');
  fs.writeFileSync(suggestionPath, out, 'utf8');
  console.log(`\nWrote scaffold: ${path.relative(REPO_ROOT, suggestionPath)}`);
  // Build consolidated .env.example
  const readEnvText = (fp) => {
    try { return fs.readFileSync(fp, 'utf8'); } catch { return ''; }
  };
  const parseKeys = (txt) => [...txt.matchAll(/^\s*([A-Z0-9_]+)\s*=/gm)].map((m) => m[1]);

  const templateTxt = readEnvText(path.join(REPO_ROOT, 'environment_template.env'));
  const mobileTxt = readEnvText(path.join(REPO_ROOT, 'mobile', '.env'));
  const backendTxt = readEnvText(path.join(REPO_ROOT, 'backend', '.env'));
  const missingTxt = readEnvText(path.join(REPO_ROOT, 'missing_env_keys.env'));

  const all = Array.from(new Set([
    ...parseKeys(templateTxt),
    ...parseKeys(mobileTxt),
    ...parseKeys(backendTxt),
    ...parseKeys(missingTxt),
  ])).sort();

  const examplePath = path.join(REPO_ROOT, '.env.example');
  const body = [
    '# Auto-generated by scripts/find-missing-envs.js',
    '# Fill values and copy into mobile/.env and backend/.env as needed.',
    '',
    ...all.map((k) => `${k}=`),
    '',
  ].join('\n');
  fs.writeFileSync(examplePath, body, 'utf8');
  console.log(`[env] Wrote ${path.relative(REPO_ROOT, examplePath)}`);
}

main();


